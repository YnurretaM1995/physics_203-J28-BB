╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║              BILLARD MASTER 3D - CODE SOURCE COMPLET              ║
║                                                                   ║
║  Système UI complet avec menu, pause, détection de victoire      ║
║  Date: 08/12/2025 23:06:58                                        ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝


═══════════════════════════════════════════════════════════════════
  FICHIER 1/10 : index.html
  Lignes :       85
═══════════════════════════════════════════════════════════════════

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billard Complet - Physique Réaliste</title>
    <link rel="stylesheet" href="css/style.css">
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
        }
    }
    </script>
</head>
<body>
    <!-- UI CONTAINER -->
    <div id="ui-layer">
        
        <!-- 1. MAIN MENU -->
        <div id="screen-menu" class="screen" style="display: flex;">
            <h1 class="game-title">BILLARD MASTER 3D</h1>
            <div class="menu-buttons">
                <button id="btn-play" class="btn primary">JOUER</button>
                <button id="btn-settings" class="btn">OPTIONS</button>
                <button id="btn-credits" class="btn small">Crédits</button>
            </div>
        </div>

        <!-- 2. SETTINGS -->
        <div id="screen-settings" class="screen" style="display: none;">
            <h2>OPTIONS</h2>
            <div class="setting-row">
                <label>Volume Musique</label>
                <input type="range" id="vol-music" min="0" max="1" step="0.1" value="0.5">
            </div>
            <div class="setting-row">
                <label>Volume SFX</label>
                <input type="range" id="vol-sfx" min="0" max="1" step="0.1" value="0.8">
            </div>
            <div class="setting-row">
                <label>Langue / Language</label>
                <select id="lang-select">
                    <option value="fr">Français</option>
                    <option value="en">English</option>
                </select>
            </div>
            <button id="btn-back-menu" class="btn">RETOUR</button>
        </div>

        <!-- 3. GAME HUD (Pendant le jeu) -->
        <div id="screen-hud" class="overlay" style="display: none;">
            <div class="top-bar">
                <div id="score-display">Joueur 1</div>
                <button id="btn-pause" class="btn-icon">⏸</button>
            </div>
            <div id="game-tips">
                Clic Bille: Viser | Glisser Blanche: Tirer
            </div>
        </div>

        <!-- 4. PAUSE MENU -->
        <div id="screen-pause" class="screen" style="display: none; background: rgba(0,0,0,0.8);">
            <h2>PAUSE</h2>
            <button id="btn-resume" class="btn primary">REPRENDRE</button>
            <button id="btn-settings-pause" class="btn">OPTIONS</button>
            <button id="btn-quit" class="btn danger">QUITTER</button>
        </div>

        <!-- 5. WIN / LOSE -->
        <div id="screen-gameover" class="screen" style="display: none;">
            <h1 id="end-title">VICTOIRE !</h1>
            <p id="end-message">Vous avez rentré la noire.</p>
            <button id="btn-restart" class="btn primary">REJOUER</button>
            <button id="btn-quit-end" class="btn">MENU PRINCIPAL</button>
        </div>

    </div>

    <script type="module" src="js/main.js"></script>
</body>
</html>


═══════════════════════════════════════════════════════════════════
  FICHIER 2/10 : css/style.css
  Lignes :      170
═══════════════════════════════════════════════════════════════════

body { 
    margin: 0; 
    overflow: hidden; 
    background-color: #050505; 
    user-select: none; 
}

/* UI GLOBAL */
#ui-layer { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    pointer-events: none; 
}

.screen {
    position: absolute; 
    width: 100%; 
    height: 100%;
    background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center;
    pointer-events: auto;
    z-index: 10;
}

.overlay { 
    position: absolute; 
    width: 100%; 
    height: 100%; 
    pointer-events: none; 
}

/* TYPOGRAPHY */
h1.game-title { 
    font-size: 4em; 
    color: #2e8b57; 
    text-shadow: 0 0 10px #00ff00; 
    margin-bottom: 50px; 
    font-family: 'Impact', sans-serif; 
    letter-spacing: 2px; 
}

h2 { 
    color: white; 
    font-family: sans-serif; 
    letter-spacing: 2px; 
}

p { 
    color: #ccc; 
    font-family: sans-serif; 
}

/* BUTTONS */
.btn {
    pointer-events: auto; 
    background: transparent; 
    border: 2px solid #555; 
    color: white;
    padding: 15px 40px; 
    margin: 10px; 
    font-size: 1.2em; 
    cursor: pointer;
    transition: all 0.2s; 
    font-family: sans-serif; 
    text-transform: uppercase; 
    min-width: 200px;
}

.btn:hover { 
    background: #333; 
    border-color: #888; 
    transform: scale(1.05); 
}

.btn.primary { 
    background: #2e8b57; 
    border-color: #2e8b57; 
    color: black; 
    font-weight: bold; 
}

.btn.primary:hover { 
    background: #3cb371; 
    color: white; 
}

.btn.danger { 
    border-color: #8b0000; 
    color: #ffcccc; 
}

.btn.danger:hover { 
    background: #8b0000; 
    color: white; 
}

.btn.small { 
    font-size: 0.8em; 
    padding: 5px 10px; 
    min-width: auto; 
    margin-top: 30px; 
    border: none; 
    color: #666; 
}

.btn-icon { 
    pointer-events: auto; 
    background: rgba(0,0,0,0.5); 
    border: none; 
    color: white; 
    font-size: 1.5em; 
    padding: 10px; 
    cursor: pointer; 
    border-radius: 5px; 
}

/* SETTINGS */
.setting-row { 
    display: flex; 
    align-items: center; 
    justify-content: space-between; 
    width: 300px; 
    margin: 10px 0; 
    color: white; 
    font-family: sans-serif; 
}

input[type=range] { 
    width: 150px; 
}

select { 
    padding: 5px; 
}

/* HUD */
.top-bar { 
    position: absolute; 
    top: 0; 
    width: 100%; 
    padding: 20px; 
    display: flex; 
    justify-content: space-between; 
    box-sizing: border-box; 
}

#score-display { 
    color: white; 
    font-family: sans-serif; 
    font-size: 1.5em; 
    background: rgba(0,0,0,0.5); 
    padding: 5px 15px; 
    border-radius: 5px; 
}

#game-tips { 
    position: absolute; 
    bottom: 20px; 
    width: 100%; 
    text-align: center; 
    color: #888; 
    font-family: sans-serif; 
    text-shadow: 1px 1px 2px black; 
}


═══════════════════════════════════════════════════════════════════
  FICHIER 3/10 : js/constants.js
  Lignes :       27
═══════════════════════════════════════════════════════════════════

// constants.js
// Constantes physiques et dimensions de la table de billard

// --- CONSTANTES PHYSIQUES ---
export const BALL_RADIUS = 0.20;
export const BALL_MASS = 0.17;
export const GRAVITY = 9.81;
export const INERTIA = 0.4 * BALL_MASS * BALL_RADIUS * BALL_RADIUS; // Inertie d'une sphère pleine : 2/5 * m * r²

// Dimensions table
export const TABLE_W = 13.0;
export const TABLE_H = 7.0;

// Dimensions détaillées de la table
export const S = 0.007353;
export const VAL_CORNER_MOUTH = 115 * S;
export const VAL_SIDE_MOUTH = 150 * S;
export const VAL_OFFSET_CORNER = 50 * S;
export const VAL_OFFSET_SIDE = 78 * S;
export const VAL_HOLE_RADIUS = 80 * S;
export const CORNER_KNUCKLE = VAL_CORNER_MOUTH / Math.sqrt(2);
export const SIDE_KNUCKLE = VAL_SIDE_MOUTH / 2;
export const RAIL_HEIGHT = 0.32;
export const RUBBER_DEPTH = 0.40;
export const WOOD_DEPTH = 0.80;
export const FRAME_WIDTH = 1.2;
export const FRAME_HEIGHT = 0.45;


═══════════════════════════════════════════════════════════════════
  FICHIER 4/10 : js/gameState.js
  Lignes :      103
═══════════════════════════════════════════════════════════════════

// gameState.js
// Machine à états pour gérer les différentes phases du jeu

// --- GAME STATE MACHINE ---

export const GameStates = {
    MENU: 'menu',           // Main menu screen
    SETTINGS: 'settings',   // Settings screen
    IDLE: 'idle',           // Waiting for player interaction
    AIMING: 'aiming',       // Player is aiming the cue
    SHOOTING: 'shooting',   // Shot has been taken, balls are moving
    PAUSED: 'paused',       // Game is paused
    GAME_OVER: 'game_over'  // Game ended
};

class GameStateMachine {
    constructor() {
        this.currentState = GameStates.IDLE;
        this.listeners = [];
        
        // Gestion des joueurs (mode 2 joueurs)
        this.currentPlayer = 1; // 1 ou 2
    }

    setState(newState) {
        const oldState = this.currentState;
        this.currentState = newState;
        console.log(`Game state: ${oldState} -> ${newState}`);
        
        // Notify listeners
        this.listeners.forEach(listener => listener(newState, oldState));
    }

    getState() {
        return this.currentState;
    }

    isIdle() {
        return this.currentState === GameStates.IDLE;
    }

    isAiming() {
        return this.currentState === GameStates.AIMING;
    }

    isShooting() {
        return this.currentState === GameStates.SHOOTING;
    }

    canAim() {
        return this.currentState === GameStates.IDLE;
    }

    canShoot() {
        return this.currentState === GameStates.AIMING;
    }

    isMenu() {
        return this.currentState === GameStates.MENU;
    }

    isPaused() {
        return this.currentState === GameStates.PAUSED;
    }

    isSettings() {
        return this.currentState === GameStates.SETTINGS;
    }

    isPlaying() {
        return this.currentState === GameStates.IDLE || 
               this.currentState === GameStates.AIMING || 
               this.currentState === GameStates.SHOOTING;
    }

    // Add listener for state changes
    onStateChange(callback) {
        this.listeners.push(callback);
    }

    // Remove listener
    removeStateChangeListener(callback) {
        this.listeners = this.listeners.filter(l => l !== callback);
    }

    // Player management
    getCurrentPlayer() {
        return this.currentPlayer;
    }

    switchPlayer() {
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        console.log(`Changement de joueur → Joueur ${this.currentPlayer}`);
        return this.currentPlayer;
    }
    
    resetPlayer() {
        this.currentPlayer = 1;
    }
}

// Export singleton instance
export const gameState = new GameStateMachine();


═══════════════════════════════════════════════════════════════════
  FICHIER 5/10 : js/ball.js
  Lignes :      140
═══════════════════════════════════════════════════════════════════

// ball.js
// Classe BilliardBall avec physique de glissement, rotation et rendu

import * as THREE from 'three';
import { BALL_RADIUS, BALL_MASS, GRAVITY, INERTIA } from './constants.js';

// Paramètres globaux (seront mis à jour depuis main.js)
let params = null;

export function setParams(p) {
    params = p;
}

// --- CLASSE BALLE ---
export class BilliardBall {
    constructor(x, z, number) {
        this.number = number; // Store ball number for game logic
        this.pos = new THREE.Vector3(x, BALL_RADIUS, z);
        this.vel = new THREE.Vector3(0, 0, 0);
        this.angVel = new THREE.Vector3(0, 0, 0); // Vitesse angulaire (rad/s)
        this.quat = new THREE.Quaternion();
        this.inPocket = false;
        
        // Visuals
        const colors = {1:0xeebb00, 2:0x0000ee, 3:0xee0000, 4:0x800080, 5:0xffa500, 6:0x006400, 7:0x800000, 8:0x111111};
        let c = (number > 8 ? colors[number - 8] : colors[number]) || 0x000000;
        const geo = new THREE.SphereGeometry(BALL_RADIUS, 32, 16);
        const mat = new THREE.MeshStandardMaterial({ 
            map: this.createBallTexture(number, c), 
            roughness: 0.1, 
            metalness: 0.1 
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.castShadow = true;
        if (number !== 0) this.mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
        this.mesh.position.copy(this.pos);
    }

    createBallTexture(number, colorHex) {
        const size = 512;
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = size;
        ctx.canvas.height = size / 2;
        const w = size, h = size / 2;
        
        ctx.fillStyle = '#fffae6';
        ctx.fillRect(0, 0, w, h);
        
        if (number === 0) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(w * 0.5, h * 0.5, h * 0.05, 0, Math.PI * 2);
            ctx.fill();
            return new THREE.CanvasTexture(ctx.canvas);
        }
        
        ctx.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
        if (number > 8) {
            ctx.fillRect(0, h * 0.25, w, h * 0.5);
        } else {
            ctx.fillRect(0, 0, w, h);
        }
        
        [w * 0.25, w * 0.75].forEach(x => {
            ctx.beginPath();
            ctx.arc(x, h * 0.5, h * 0.35, 0, Math.PI * 2);
            ctx.fillStyle = '#fffae6';
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.font = `bold ${h * 0.4}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, x, h * 0.52);
        });
        
        const t = new THREE.CanvasTexture(ctx.canvas);
        t.minFilter = THREE.LinearFilter;
        return t;
    }

    update(dt) {
        if (this.inPocket) return;

        // 1. Calcul de la vitesse relative au point de contact (v_slide)
        // v_contact = v + (omega x r)
        // r est le vecteur du centre vers le bas (0, -R, 0)
        const rVector = new THREE.Vector3(0, -BALL_RADIUS, 0);
        const vRot = new THREE.Vector3().crossVectors(this.angVel, rVector);
        const vSlide = new THREE.Vector3().addVectors(this.vel, vRot);
        vSlide.y = 0; // On reste sur le plan 2D

        const slideSpeed = vSlide.length();

        // 2. Application des forces
        if (slideSpeed > 0.01) {
            // --- ETAT GLISSEMENT (SLIDING) ---
            // Force de friction opposée au glissement
            const frictionDir = vSlide.normalize().negate();
            const frictionMag = params.muSlide * BALL_MASS * GRAVITY;
            const frictionForce = frictionDir.multiplyScalar(frictionMag);

            // a. Impact sur la vitesse linéaire (F = ma)
            const linearAcc = frictionForce.clone().divideScalar(BALL_MASS);
            this.vel.addScaledVector(linearAcc, dt);

            // b. Impact sur la vitesse angulaire (Torque = r x F)
            const torque = new THREE.Vector3().crossVectors(rVector, frictionForce);
            const angularAcc = torque.divideScalar(INERTIA);
            this.angVel.addScaledVector(angularAcc, dt);
        } else {
            // --- ETAT ROULEMENT (ROLLING) ---
            // Résistance simple au roulement pour arrêter la bille progressivement
            const k = 1 - (params.muRoll * dt * 10);
            this.vel.multiplyScalar(k);
            this.angVel.multiplyScalar(k);
            
            // Seuil d'arrêt
            if (this.vel.lengthSq() < 0.0001) {
                this.vel.set(0, 0, 0);
                this.angVel.set(0, 0, 0);
            }
        }

        // 3. Intégration Position
        this.pos.addScaledVector(this.vel, dt);

        // 4. Intégration Rotation (Quaternion) via angVel réel
        const omegaLen = this.angVel.length();
        if (omegaLen > 0.000001) {
            const axis = this.angVel.clone().normalize();
            const angle = omegaLen * dt;
            const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
            this.quat.premultiply(q);
        }

        // 5. Mise à jour Mesh
        this.mesh.position.copy(this.pos);
        this.mesh.quaternion.copy(this.quat);
    }
}


═══════════════════════════════════════════════════════════════════
  FICHIER 6/10 : js/table.js
  Lignes :      181
═══════════════════════════════════════════════════════════════════

// table.js
// Construction de la table de billard avec bandes, trous et géométrie

import * as THREE from 'three';
import { 
    TABLE_W, TABLE_H, RUBBER_DEPTH, RAIL_HEIGHT, WOOD_DEPTH, 
    FRAME_WIDTH, FRAME_HEIGHT, VAL_HOLE_RADIUS, VAL_OFFSET_CORNER, 
    VAL_OFFSET_SIDE, CORNER_KNUCKLE, SIDE_KNUCKLE, S
} from './constants.js';

export let walls2D = [];

export function createTable(scene) {
    const floorW = TABLE_W + (RUBBER_DEPTH + FRAME_WIDTH) * 2;
    const floorH = TABLE_H + (RUBBER_DEPTH + FRAME_WIDTH) * 2;
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(floorW, floorH), 
        new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.8 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    walls2D = [];

    function buildSolidRail(p1, p2, normal) {
        const vecDir = new THREE.Vector3().subVectors(p2, p1).normalize();
        const facingSpread = RUBBER_DEPTH * 0.7;
        const p4 = p1.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(-facingSpread));
        const p3 = p2.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(facingSpread));

        const shape = new THREE.Shape();
        shape.moveTo(p1.x, p1.z);
        shape.lineTo(p2.x, p2.z);
        shape.lineTo(p3.x, p3.z);
        shape.lineTo(p4.x, p4.z);
        
        const geom = new THREE.ExtrudeGeometry(shape, { depth: RAIL_HEIGHT, bevelEnabled: false });
        geom.rotateX(Math.PI / 2);
        geom.translate(0, RAIL_HEIGHT, 0);
        const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color: 0x247a46, roughness: 0.6 }));
        mesh.castShadow = true;
        scene.add(mesh);

        const w1 = p4.clone();
        const w2 = p3.clone();
        const w3 = w2.clone().add(normal.clone().multiplyScalar(WOOD_DEPTH));
        const w4 = w1.clone().add(normal.clone().multiplyScalar(WOOD_DEPTH));
        const mitre = WOOD_DEPTH * 0.8;
        w3.add(vecDir.clone().multiplyScalar(mitre));
        w4.add(vecDir.clone().multiplyScalar(-mitre));
        
        const wShape = new THREE.Shape();
        wShape.moveTo(w1.x, w1.z);
        wShape.lineTo(w2.x, w2.z);
        wShape.lineTo(w3.x, w3.z);
        wShape.lineTo(w4.x, w4.z);
        
        const wGeom = new THREE.ExtrudeGeometry(wShape, { depth: RAIL_HEIGHT + 0.05, bevelEnabled: false });
        wGeom.rotateX(Math.PI / 2);
        wGeom.translate(0, RAIL_HEIGHT + 0.05, 0);
        scene.add(new THREE.Mesh(wGeom, new THREE.MeshStandardMaterial({ color: 0x5c4033 })));

        addWallSegment(p4, p1);
        addWallSegment(p1, p2);
        addWallSegment(p2, p3);
    }

    function addWallSegment(a, b) {
        const dx = b.x - a.x;
        const dz = b.z - a.z;
        const len = Math.sqrt(dx * dx + dz * dz);
        walls2D.push({ 
            p1: a, 
            p2: b, 
            normal: { x: dz / len, z: -dx / len }, 
            lenSq: len * len 
        });
    }

    const W = TABLE_W / 2;
    const H = TABLE_H / 2;
    
    buildSolidRail(
        new THREE.Vector3(-W + CORNER_KNUCKLE, 0, -H), 
        new THREE.Vector3(-SIDE_KNUCKLE, 0, -H), 
        new THREE.Vector3(0, 0, -1)
    );
    buildSolidRail(
        new THREE.Vector3(SIDE_KNUCKLE, 0, -H), 
        new THREE.Vector3(W - CORNER_KNUCKLE, 0, -H), 
        new THREE.Vector3(0, 0, -1)
    );
    buildSolidRail(
        new THREE.Vector3(W, 0, -H + CORNER_KNUCKLE), 
        new THREE.Vector3(W, 0, H - CORNER_KNUCKLE), 
        new THREE.Vector3(1, 0, 0)
    );
    buildSolidRail(
        new THREE.Vector3(W - CORNER_KNUCKLE, 0, H), 
        new THREE.Vector3(SIDE_KNUCKLE, 0, H), 
        new THREE.Vector3(0, 0, 1)
    );
    buildSolidRail(
        new THREE.Vector3(-SIDE_KNUCKLE, 0, H), 
        new THREE.Vector3(-W + CORNER_KNUCKLE, 0, H), 
        new THREE.Vector3(0, 0, 1)
    );
    buildSolidRail(
        new THREE.Vector3(-W, 0, H - CORNER_KNUCKLE), 
        new THREE.Vector3(-W, 0, -H + CORNER_KNUCKLE), 
        new THREE.Vector3(-1, 0, 0)
    );

    // Cadre & Trous
    createCabinet(scene);
    createHoles(scene);
}

function createCabinet(scene) {
    const W = TABLE_W / 2;
    const H = TABLE_H / 2;
    const innerW = W + RUBBER_DEPTH;
    const innerH = H + RUBBER_DEPTH;
    const outerW = innerW + FRAME_WIDTH;
    const outerH = innerH + FRAME_WIDTH;
    
    const shape = new THREE.Shape();
    shape.moveTo(-outerW, -outerH);
    shape.lineTo(outerW, -outerH);
    shape.lineTo(outerW, outerH);
    shape.lineTo(-outerW, outerH);
    shape.lineTo(-outerW, -outerH);
    
    const hole = new THREE.Path();
    hole.moveTo(-innerW, -innerH);
    hole.lineTo(innerW, -innerH);
    hole.lineTo(innerW, innerH);
    hole.lineTo(-innerW, innerH);
    hole.lineTo(-innerW, -innerH);
    shape.holes.push(hole);
    
    const geom = new THREE.ExtrudeGeometry(shape, { 
        depth: FRAME_HEIGHT, 
        bevelEnabled: true, 
        bevelThickness: 0.05, 
        bevelSize: 0.05, 
        bevelSegments: 2 
    });
    geom.rotateX(Math.PI / 2);
    geom.translate(0, FRAME_HEIGHT, 0);
    scene.add(new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ 
        color: 0x5c4033, 
        roughness: 0.4 
    })));
}

function createHoles(scene) {
    const holeGeo = new THREE.CylinderGeometry(VAL_HOLE_RADIUS, VAL_HOLE_RADIUS, 0.5, 32);
    const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    
    const W = TABLE_W / 2;
    const H = TABLE_H / 2;
    const dX = Math.cos(Math.PI / 4) * VAL_OFFSET_CORNER;
    const dZ = Math.sin(Math.PI / 4) * VAL_OFFSET_CORNER;
    
    const pp = [
        { x: -W - dX, z: -H - dZ },
        { x: W + dX, z: -H - dZ },
        { x: 0, z: -H - VAL_OFFSET_SIDE },
        { x: -W - dX, z: H + dZ },
        { x: W + dX, z: H + dZ },
        { x: 0, z: H + VAL_OFFSET_SIDE }
    ];
    
    pp.forEach(p => {
        const m = new THREE.Mesh(holeGeo, holeMat);
        m.position.set(p.x, -0.1, p.z);
        scene.add(m);
    });
}


═══════════════════════════════════════════════════════════════════
  FICHIER 7/10 : js/physics.js
  Lignes :      139
═══════════════════════════════════════════════════════════════════

// physics.js
// Moteur physique : collisions, murs, trous et mise à jour des billes

import * as THREE from 'three';
import { BALL_RADIUS, TABLE_W, TABLE_H, VAL_HOLE_RADIUS, VAL_OFFSET_CORNER, VAL_OFFSET_SIDE } from './constants.js';
import { walls2D } from './table.js';

// Paramètres globaux
let params = null;

export function setParams(p) {
    params = p;
}

// --- MOTEUR PHYSIQUE ---
export function updatePhysics(balls, dt, turnInfo = null) {
    const sub = 15;
    const subDt = dt / sub;
    
    for (let s = 0; s < sub; s++) {
        // Collisions Balles (Choc Elastique Simple sur la vitesse linéaire)
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                const b1 = balls[i], b2 = balls[j];
                if (b1.inPocket || b2.inPocket) continue;
                
                const dv = new THREE.Vector3().subVectors(b2.pos, b1.pos);
                const d = dv.length();
                
                if (d < BALL_RADIUS * 2) {
                    const n = dv.normalize();
                    const pen = (BALL_RADIUS * 2 - d) * 0.5;
                    
                    b1.pos.sub(n.clone().multiplyScalar(pen));
                    b2.pos.add(n.clone().multiplyScalar(pen));
                    
                    const vRel = new THREE.Vector3().subVectors(b1.vel, b2.vel).dot(n);
                    if (vRel < 0) continue;
                    
                    const imp = n.multiplyScalar(-(1 + params.restitution) * vRel * 0.5);
                    b1.vel.add(imp);
                    b2.vel.sub(imp);
                    
                    // Note : Le transfert de spin entre billes est ignoré ici pour simplifier,
                    // mais la friction table/bille va rétablir le roulement naturel après le choc.
                }
            }
        }

        balls.forEach(b => {
            // Murs 2D
            for (let w of walls2D) {
                const abx = w.p2.x - w.p1.x;
                const abz = w.p2.z - w.p1.z;
                const apx = b.pos.x - w.p1.x;
                const apz = b.pos.z - w.p1.z;
                
                let t = (apx * abx + apz * abz) / w.lenSq;
                t = Math.max(0, Math.min(1, t));
                
                const cx = w.p1.x + t * abx;
                const cz = w.p1.z + t * abz;
                const dx = b.pos.x - cx;
                const dz = b.pos.z - cz;
                const dSq = dx * dx + dz * dz;
                
                if (dSq < BALL_RADIUS * BALL_RADIUS) {
                    const dist = Math.sqrt(dSq);
                    let nx, nz;
                    
                    if (dist < 1e-5) {
                        nx = w.normal.x;
                        nz = w.normal.z;
                    } else {
                        nx = dx / dist;
                        nz = dz / dist;
                    }
                    
                    b.pos.x += nx * (BALL_RADIUS - dist);
                    b.pos.z += nz * (BALL_RADIUS - dist);
                    
                    const vn = b.vel.x * nx + b.vel.z * nz;
                    if (vn < 0) {
                        const j = -(1 + params.wallRestitution) * vn;
                        b.vel.x += nx * j;
                        b.vel.z += nz * j;
                        // On réduit un peu le spin au contact bande
                        b.angVel.multiplyScalar(0.9);
                    }
                }
            }

            // Trous
            const W = TABLE_W / 2;
            const H = TABLE_H / 2;
            const dX = Math.cos(Math.PI / 4) * VAL_OFFSET_CORNER;
            const dZ = Math.sin(Math.PI / 4) * VAL_OFFSET_CORNER;
            
            const pp = [
                { x: -W - dX, z: -H - dZ },
                { x: W + dX, z: -H - dZ },
                { x: 0, z: -H - VAL_OFFSET_SIDE },
                { x: -W - dX, z: H + dZ },
                { x: W + dX, z: H + dZ },
                { x: 0, z: H + VAL_OFFSET_SIDE }
            ];
            
            for (let p of pp) {
                const dx = b.pos.x - p.x;
                const dz = b.pos.z - p.z;
                if (dx * dx + dz * dz < VAL_HOLE_RADIUS * VAL_HOLE_RADIUS) {
                    if (!b.inPocket) { // Éviter de compter plusieurs fois
                        b.inPocket = true;
                        b.vel.set(0, 0, 0);
                        b.angVel.set(0, 0, 0);
                        b.mesh.visible = false;
                        
                        // Enregistrer l'événement pour le système de tour
                        if (turnInfo) {
                            if (b === window.whiteBall) {
                                turnInfo.whiteScratched = true;
                                setTimeout(() => window.resetWhiteBall(), 1000);
                            } else {
                                // Bille normale empochée
                                turnInfo.ballsPotted.push(b.number);
                                console.log(`Bille ${b.number} empochée`);
                            }
                        } else if (b === window.whiteBall) {
                            setTimeout(() => window.resetWhiteBall(), 1000);
                        }
                    }
                }
            }

            // Mise à jour Physique (Frottement, Rotation, Glissement)
            b.update(subDt);
        });
    }
}


═══════════════════════════════════════════════════════════════════
  FICHIER 8/10 : js/ui.js
  Lignes :      162
═══════════════════════════════════════════════════════════════════

// ui.js
// Interface utilisateur : GUI, contrôles de visée et gestion des événements

import * as THREE from 'three';
import GUI from 'lil-gui';
import { BALL_RADIUS } from './constants.js';
import { gameState, GameStates } from './gameState.js';

// Variables globales
let scene, camera, controls, whiteBall, cueStick, aimLine;
let params = null;

// État de la souris
const mouseState = {
    isAiming: false,
    startPos: new THREE.Vector3(),
    currentPos: new THREE.Vector3(),
    power: 0,
    angle: 0
};

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

export function setGlobalVariables(s, c, ctrls, wb, cs, al, p) {
    scene = s;
    camera = c;
    controls = ctrls;
    whiteBall = wb;
    cueStick = cs;
    aimLine = al;
    params = p;
}

export function updateWhiteBall(wb) {
    whiteBall = wb;
}

export function setupGUI(params) {
    const gui = new GUI({ title: 'Billard Physique' });
    
    gui.add(params, 'cueHeight', -BALL_RADIUS * 0.8, BALL_RADIUS * 0.8)
        .name('↕ Point d\'impact')
        .onChange(() => {
            if (cueStick.visible) cueStick.position.y = BALL_RADIUS + params.cueHeight;
        });
    
    gui.add(params, 'maxPower', 10, 50).name('Puissance Max');
    
    const f = gui.addFolder('Réglages Physique').close();
    f.add(params, 'muSlide', 0.05, 0.5).name('Frottement Tapis');
    f.add(params, 'muRoll', 0.001, 0.1).name('Résist. Roulement');
    f.add(params, 'restitution', 0.1, 1.0).name('Rebond Billes');
    f.add(params, 'wallRestitution', 0.1, 1.0).name('Rebond Bandes');
    
    return gui;
}

export function setupEventListeners() {
    window.addEventListener('resize', onResize);
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') window.resetGame();
    });
}

// --- LOGIQUE CAMERA & VISÉE ---
function onMouseDown(e) {
    // Only allow interaction when game is idle (not in menu, pause, settings, etc)
    if (!gameState.canAim() || !gameState.isPlaying()) return;
    
    updateMouse(e);
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(window.balls.map(b => b.mesh));
    if (intersects.length > 0) {
        const hitObj = intersects[0].object;
        if (hitObj === whiteBall.mesh) {
            mouseState.isAiming = true;
            gameState.setState(GameStates.AIMING);
            controls.enabled = false;
            raycaster.ray.intersectPlane(planeY, mouseState.startPos);
            cueStick.visible = true;
            cueStick.position.y = BALL_RADIUS + params.cueHeight;
            aimLine.visible = true;
        } else {
            focusCameraOnTarget(window.balls.find(b => b.mesh === hitObj));
        }
    }
}

function focusCameraOnTarget(target) {
    const direction = new THREE.Vector3().subVectors(target.pos, whiteBall.pos).normalize();
    const angle = Math.atan2(direction.z, direction.x);
    mouseState.angle = angle;
    
    const camPos = whiteBall.pos.clone()
        .sub(direction.clone().multiplyScalar(8))
        .add(new THREE.Vector3(0, 10, 0));
    
    camera.position.copy(camPos);
    controls.target.copy(whiteBall.pos);
    controls.update();
    
    cueStick.visible = true;
    cueStick.position.copy(whiteBall.pos);
    cueStick.position.y = BALL_RADIUS + params.cueHeight;
    cueStick.rotation.y = -angle - Math.PI / 2;
    cueStick.translateZ(0.2);
    
    aimLine.visible = true;
    aimLine.position.copy(whiteBall.pos);
    aimLine.rotation.y = -angle;
}

function onMouseMove(e) {
    if (!mouseState.isAiming) return;
    
    updateMouse(e);
    raycaster.setFromCamera(mouse, camera);
    raycaster.ray.intersectPlane(planeY, mouseState.currentPos);
    
    const v = new THREE.Vector3().subVectors(whiteBall.pos, mouseState.currentPos);
    const angle = Math.atan2(v.z, v.x);
    const dist = Math.min(v.length() * 4, params.maxPower);
    
    mouseState.angle = angle;
    mouseState.power = dist;

    cueStick.position.copy(whiteBall.pos);
    cueStick.position.y = BALL_RADIUS + params.cueHeight;
    cueStick.rotation.y = -angle - Math.PI / 2;
    cueStick.translateZ(dist * 0.1);

    aimLine.position.copy(whiteBall.pos);
    aimLine.rotation.y = -angle;
}

function onMouseUp() {
    if (!mouseState.isAiming) return;
    
    window.shootBall(mouseState.angle, mouseState.power);
    mouseState.isAiming = false;
    gameState.setState(GameStates.SHOOTING);
    cueStick.visible = false;
    aimLine.visible = false;
    controls.enabled = true;
}

function updateMouse(e) {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    window.renderer.setSize(window.innerWidth, window.innerHeight);
}


═══════════════════════════════════════════════════════════════════
  FICHIER 9/10 : js/menuManager.js
  Lignes :      194
═══════════════════════════════════════════════════════════════════

// menuManager.js
// Gestion des écrans UI, transitions et logique de menu

import { gameState, GameStates } from './gameState.js';

// Settings
export const settings = {
    musicVol: 0.5,
    sfxVol: 0.8,
    lang: 'fr'
};

// Textes (Localization)
const TEXTS = {
    fr: { 
        win: "VICTOIRE !", 
        lose: "DÉFAITE...", 
        msgWin: "Table nettoyée !", 
        msgLose: "La blanche est tombée ou faute.",
        niceShotContinue: "Joli coup ! Rejouez.",
        foulScratch: "Faute ! Blanche empochée.",
        missedTurn: "Raté ! Au tour de l'adversaire."
    },
    en: { 
        win: "YOU WIN!", 
        lose: "GAME OVER", 
        msgWin: "Table cleared!", 
        msgLose: "Scratch or foul.",
        niceShotContinue: "Nice shot! Play again.",
        foulScratch: "Foul! White ball pocketed.",
        missedTurn: "Missed! Opponent's turn."
    }
};

// Variables globales pour les callbacks
let onPlayCallback = null;
let onResetCallback = null;
let controls = null;

// Mémoriser l'état avant d'aller dans SETTINGS
let previousState = null;

export function setMenuCallbacks(onPlay, onReset, ctrls) {
    onPlayCallback = onPlay;
    onResetCallback = onReset;
    controls = ctrls;
}

// Fonction principale pour changer d'état et afficher le bon écran
export function switchState(newState) {
    gameState.setState(newState);
    
    // Cacher tous les écrans
    ['screen-menu', 'screen-settings', 'screen-hud', 'screen-pause', 'screen-gameover'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });

    // Logique par état
    switch(newState) {
        case GameStates.MENU:
            document.getElementById('screen-menu').style.display = 'flex';
            if (controls) controls.enabled = true;
            break;
            
        case GameStates.IDLE:
        case GameStates.AIMING:
        case GameStates.SHOOTING:
            document.getElementById('screen-hud').style.display = 'block';
            if (controls) controls.enabled = true;
            updateHUD();
            break;
            
        case GameStates.PAUSED:
            document.getElementById('screen-hud').style.display = 'block';
            document.getElementById('screen-pause').style.display = 'flex';
            if (controls) controls.enabled = false;
            break;
            
        case GameStates.SETTINGS:
            document.getElementById('screen-settings').style.display = 'flex';
            break;
            
        case GameStates.GAME_OVER:
            document.getElementById('screen-gameover').style.display = 'flex';
            if (controls) controls.enabled = false;
            break;
    }
}

// Mise à jour du HUD
export function updateHUD() {
    const player = gameState.getCurrentPlayer();
    const t = TEXTS[settings.lang];
    
    const label = settings.lang === 'fr' ? `Joueur ${player}` : `Player ${player}`;
    const el = document.getElementById('score-display');
    
    el.innerText = label;
    
    // Couleur distinctive par joueur
    if (player === 1) {
        el.style.borderLeft = "5px solid #0055ff"; // Bleu pour J1
        el.style.color = "white";
    } else {
        el.style.borderLeft = "5px solid #ff5500"; // Orange pour J2
        el.style.color = "white";
    }
}

// Afficher l'écran de fin de partie
export function triggerGameOver(isWin, reason) {
    switchState(GameStates.GAME_OVER);
    const t = TEXTS[settings.lang];
    document.getElementById('end-title').innerText = isWin ? t.win : t.lose;
    document.getElementById('end-message').innerText = reason || (isWin ? t.msgWin : t.msgLose);
    document.getElementById('end-title').style.color = isWin ? '#2e8b57' : '#8b0000';
}

// Configuration des événements UI
export function setupUI() {
    // MENU
    document.getElementById('btn-play').onclick = () => {
        if (onResetCallback) onResetCallback();
        switchState(GameStates.IDLE);
        if (onPlayCallback) onPlayCallback();
    };
    
    document.getElementById('btn-settings').onclick = () => {
        previousState = GameStates.MENU; // Vient du menu principal
        document.getElementById('screen-menu').style.display = 'none';
        switchState(GameStates.SETTINGS);
    };

    document.getElementById('btn-credits').onclick = () => {
        alert('Billard Master 3D\nDéveloppé avec Three.js\n© 2024');
    };

    // SETTINGS
    document.getElementById('btn-back-menu').onclick = () => {
        document.getElementById('screen-settings').style.display = 'none';
        // Retour à l'état précédent (MENU ou PAUSED)
        if(previousState === GameStates.PAUSED) {
            switchState(GameStates.PAUSED);
        } else {
            switchState(GameStates.MENU);
        }
        previousState = null; // Reset
    };
    
    document.getElementById('vol-music').oninput = (e) => { 
        settings.musicVol = parseFloat(e.target.value);
        // TODO: Update Audio when implemented
    };
    
    document.getElementById('vol-sfx').oninput = (e) => { 
        settings.sfxVol = parseFloat(e.target.value);
        // TODO: Update Audio when implemented
    };
    
    document.getElementById('lang-select').onchange = (e) => { 
        settings.lang = e.target.value;
        updateHUD();
    };

    // HUD / PAUSE
    document.getElementById('btn-pause').onclick = () => {
        switchState(GameStates.PAUSED);
    };
    
    document.getElementById('btn-resume').onclick = () => {
        switchState(GameStates.IDLE);
    };
    
    document.getElementById('btn-settings-pause').onclick = () => {
        previousState = GameStates.PAUSED; // Vient du menu pause
        document.getElementById('screen-pause').style.display = 'none';
        switchState(GameStates.SETTINGS);
    };
    
    document.getElementById('btn-quit').onclick = () => {
        switchState(GameStates.MENU);
    };

    // GAME OVER
    document.getElementById('btn-restart').onclick = () => {
        if (onResetCallback) onResetCallback();
        switchState(GameStates.IDLE);
    };
    
    document.getElementById('btn-quit-end').onclick = () => {
        switchState(GameStates.MENU);
    };
}


═══════════════════════════════════════════════════════════════════
  FICHIER 10/10 : js/main.js
  Lignes :      316
═══════════════════════════════════════════════════════════════════

// main.js
// Point d'entrée principal : initialisation, boucle de jeu et gestion globale

import * as THREE from 'three';
import { OrbitControls } from 'jsm/controls/OrbitControls.js';
import { BilliardBall, setParams as setBallParams } from './ball.js';
import { createTable } from './table.js';
import { updatePhysics, setParams as setPhysicsParams } from './physics.js';
import { setupGUI, setupEventListeners, setGlobalVariables, updateWhiteBall } from './ui.js';
import { TABLE_W, TABLE_H, BALL_RADIUS, INERTIA, BALL_MASS } from './constants.js';
import { gameState, GameStates } from './gameState.js';
import { setupUI, switchState, triggerGameOver, setMenuCallbacks, updateHUD } from './menuManager.js';

// --- PARAMÈTRES MODIFIABLES ---
export const params = {
    muSlide: 0.2,    // Coefficient de glissement (Tapis)
    muRoll: 0.07,    // Résistance au roulement
    restitution: 0.90, // Rebond billes
    wallRestitution: 0.6,
    maxPower: 25.0, 
    cueHeight: 0.0, 
    showDebug: false
};

// Variables globales
export let scene, camera, renderer, controls, gui;
export let balls = [], whiteBall;
let cueStick, aimLine;

// Suivi du tour actuel (pour le système 2 joueurs)
let turnInfo = {
    whiteScratched: false,
    ballsPotted: []
};

// Initialisation
init();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 12, 10);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lumières
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const light = new THREE.SpotLight(0xffffff, 800);
    light.position.set(0, 15, 0);
    light.castShadow = true;
    light.shadow.mapSize.set(2048, 2048);
    scene.add(light);

    // Configuration
    setBallParams(params);
    setPhysicsParams(params);

    // Construction de la scène
    createTable(scene);
    resetGame();
    createCue();
    
    // Contrôles
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;
    
    // UI et contrôles
    setGlobalVariables(scene, camera, controls, whiteBall, cueStick, aimLine, params);
    gui = setupGUI(params);
    setupEventListeners();

    // Rendre les variables globales accessibles pour les fonctions UI
    window.balls = balls;
    window.whiteBall = whiteBall;
    window.renderer = renderer;
    window.resetGame = resetGame;
    window.resetWhiteBall = resetWhiteBall;
    window.shootBall = shootBall;

    // Setup menu system
    setMenuCallbacks(onGameStart, resetGame, controls);
    setupUI();
    switchState(GameStates.MENU);

    renderer.setAnimationLoop(animate);
}

function createCue() {
    const g = new THREE.CylinderGeometry(0.04, 0.08, 3, 12);
    g.rotateX(-Math.PI / 2);
    g.translate(0, 0, 1.7);
    
    cueStick = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color: 0xdeb887 }));
    scene.add(cueStick);
    cueStick.visible = false;

    aimLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0), 
            new THREE.Vector3(3, 0, 0)
        ]), 
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })
    );
    scene.add(aimLine);
    aimLine.visible = false;
}

export function resetGame() {
    // Nettoyer les billes existantes
    balls.forEach(b => scene.remove(b.mesh));
    balls = [];
    
    // Créer la nouvelle configuration
    whiteBall = new BilliardBall(-TABLE_W / 4, 0, 0);
    scene.add(whiteBall.mesh);
    balls.push(whiteBall);
    
    const startX = TABLE_W / 4;
    const rS = BALL_RADIUS * 1.732;
    const cS = BALL_RADIUS * 2.01;
    const p = [1, 10, 2, 3, 8, 11, 12, 5, 13, 4, 6, 14, 7, 15, 9];
    
    let k = 0;
    for (let r = 0; r < 5; r++) {
        for (let i = 0; i <= r; i++) {
            const ball = new BilliardBall(startX + r * rS, (i - r / 2) * cS, p[k++]);
            scene.add(ball.mesh);
            balls.push(ball);
        }
    }
    
    // Mettre à jour les variables globales
    window.balls = balls;
    window.whiteBall = whiteBall;
    
    // Update whiteBall reference in ui.js
    updateWhiteBall(whiteBall);
    
    // Reset game state only if not in menu
    if (!gameState.isMenu()) {
        gameState.setState(GameStates.IDLE);
    }
    
    // Reset au Joueur 1
    gameState.resetPlayer();
    updateHUD();
}

function onGameStart() {
    // Called when game starts from menu
    console.log('Game started!');
}

export function resetWhiteBall() {
    whiteBall.inPocket = false;
    whiteBall.mesh.visible = true;
    whiteBall.pos.set(-TABLE_W / 4, BALL_RADIUS, 0);
    whiteBall.vel.set(0, 0, 0);
    whiteBall.angVel.set(0, 0, 0);
}

// --- NOUVEAU SHOOT : Gère correctement la vitesse angulaire ---
export function shootBall(angle, power) {
    // Réinitialiser les infos du tour au moment du tir
    turnInfo = {
        whiteScratched: false,
        ballsPotted: []
    };
    
    const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
    
    // 1. Vitesse Linéaire
    const speed = power;
    whiteBall.vel.copy(dir.clone().multiplyScalar(speed));
    
    // 2. Vitesse Angulaire (Coup décentré)
    const h = params.cueHeight;
    const impactPoint = new THREE.Vector3(0, h, 0);
    
    // Force appliquée dans la direction du tir
    const forceDir = dir.clone();
    const forceMag = power * BALL_MASS * 50; // Facteur arbitraire pour sentir l'effet
    const forceVec = forceDir.multiplyScalar(forceMag);

    // Torque = r x F
    const torque = new THREE.Vector3().crossVectors(impactPoint, forceVec);
    
    // Angular Acc = Torque / Inertia -> AngVel += Angular Acc * dt (impulse approximation)
    const impulseDt = 0.01; // Temps de contact fictif
    whiteBall.angVel.add(torque.divideScalar(INERTIA).multiplyScalar(impulseDt));
}

// --- MOTEUR PHYSIQUE ---
function animate() {
    // Si PAUSED, on arrête la physique mais on continue le rendu
    if (gameState.isPaused() || gameState.isSettings()) {
        renderer.render(scene, camera);
        return;
    }

    controls.update();
    
    // Physique active en MENU (pour l'effet visuel) et pendant le jeu
    if (gameState.isPlaying() || gameState.isMenu()) {
        // Passer turnInfo à updatePhysics pour tracker les billes empochées
        updatePhysics(balls, 0.016, gameState.isPlaying() ? turnInfo : null);
        
        // Check if all balls have stopped moving (only during gameplay)
        if (gameState.isShooting()) {
            const allStopped = balls.every(b => 
                b.inPocket || b.vel.lengthSq() < 0.0001
            );
            
            if (allStopped) {
                gameState.setState(GameStates.IDLE);
                
                // Logique de changement de tour
                handleTurnEnd();
                
                checkWinCondition();
            }
        }
    }
    
    // Camera rotation in menu for visual effect
    if (gameState.isMenu()) {
        const time = Date.now() * 0.0003;
        camera.position.x = Math.sin(time) * 12;
        camera.position.z = Math.cos(time) * 12;
        camera.lookAt(0, 0, 0);
    }
    
    renderer.render(scene, camera);
}

// --- DETECTION FIN DE PARTIE ---
function checkWinCondition() {
    // Only check during gameplay
    if (!gameState.isPlaying()) return;
    
    // 1. Si la blanche est tombée -> Perdu
    if (whiteBall.inPocket) {
        triggerGameOver(false, "Faute : Blanche empochée !");
        return;
    }

    // 2. Si la noire (8) est tombée
    const blackBall = balls.find(b => b.number === 8);
    if (blackBall && blackBall.inPocket) {
        // Check if all other balls (except white and black) are pocketed
        const otherBalls = balls.filter(b => b.number !== 0 && b.number !== 8);
        const allOthersPocketed = otherBalls.every(b => b.inPocket);
        
        if (allOthersPocketed) {
            triggerGameOver(true, "Parfait ! Toutes les billes empochées !");
        } else {
            triggerGameOver(false, "Noire empochée trop tôt !");
        }
        return;
    }
    
    // 3. Logic simple : Si toutes les billes (sauf blanche et noire) sont rentrées
    const regularBalls = balls.filter(b => b.number !== 0 && b.number !== 8);
    const allRegularsPocketed = regularBalls.every(b => b.inPocket);
    
    if (allRegularsPocketed && blackBall && !blackBall.inPocket) {
        // All regular balls pocketed, only black ball remains
        // Player can now try to pocket the black ball
        console.log('Toutes les billes empochées sauf la noire !');
    }
}

// --- GESTION DES TOURS (2 JOUEURS) ---
function handleTurnEnd() {
    let switchTurn = true;
    let message = "";

    // 1. Faute : La blanche est tombée
    if (turnInfo.whiteScratched) {
        message = "Faute ! Blanche empochée.";
        switchTurn = true;
    }
    // 2. Succès : Au moins une bille (autre que blanche/noire) est tombée
    else if (turnInfo.ballsPotted.length > 0) {
        const hasBlack = turnInfo.ballsPotted.includes(8);
        
        if (!hasBlack) {
            // Bon tir ! Le joueur garde la main
            switchTurn = false;
            message = "Joli coup ! Rejouez.";
        }
        // Si la noire est tombée, checkWinCondition() gère la victoire/défaite
    }
    // 3. Rien n'est tombé
    else {
        switchTurn = true;
        message = "Raté ! Au tour de l'adversaire.";
    }

    if (switchTurn) {
        gameState.switchPlayer();
    }
    
    // Mettre à jour l'affichage du joueur
    updateHUD();
    
    console.log(`Fin du tour. Empochées: ${turnInfo.ballsPotted.length}. Faute: ${turnInfo.whiteScratched}. Prochain: J${gameState.getCurrentPlayer()}`);
    if (message) console.log(message);
}


═══════════════════════════════════════════════════════════════════
  FIN DE LA COMPILATION
═══════════════════════════════════════════════════════════════════

Statistiques:
  - Fichiers compilés : 10/10
  - Lignes totales    : 1517
  - Date              : 08/12/2025 23:06:58

