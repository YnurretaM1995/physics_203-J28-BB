<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billard Complet - Physique Réaliste</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; user-select: none; }
        #instructions {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #888; font-family: sans-serif; pointer-events: none;
            text-shadow: 1px 1px 2px black; font-size: 1.1em;
        }
        #tip {
            position: absolute; top: 10px; left: 10px; color: #aaa; font-family: sans-serif;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; font-size: 0.9em;
            pointer-events: none;
        }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
        }
    }
    </script>
</head>
<body>
    <div id="tip">
        <b>Clic Bille Couleur</b> : Orienter caméra<br>
        <b>Clic/Glisser Blanche</b> : Tirer<br>
        <b>Espace</b> : Reset<br>
        <span style="color:#eeaa00">Physique : Glissement & Effets activés</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'jsm/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        // --- 1. CONSTANTES PHYSIQUES ---
        const BALL_RADIUS = 0.20; 
        const BALL_MASS = 0.17; 
        const GRAVITY = 9.81;
        // Inertie d'une sphère pleine : 2/5 * m * r²
        const INERTIA = 0.4 * BALL_MASS * BALL_RADIUS * BALL_RADIUS; 
        
        const TABLE_W = 10.0;
        const TABLE_H = 5.0;
        
        // Dimensions table (inchangées)
        const S = 0.007353;
        const VAL_CORNER_MOUTH = 115 * S; const VAL_SIDE_MOUTH = 150 * S;   
        const VAL_OFFSET_CORNER = 50 * S; const VAL_OFFSET_SIDE = 78 * S;   
        const VAL_HOLE_RADIUS = 80 * S;   
        const CORNER_KNUCKLE = VAL_CORNER_MOUTH / Math.sqrt(2); 
        const SIDE_KNUCKLE = VAL_SIDE_MOUTH / 2;
        const RAIL_HEIGHT = 0.32;    
        const RUBBER_DEPTH = 0.40;   
        const WOOD_DEPTH = 0.80;     
        const FRAME_WIDTH = 1.2;
        const FRAME_HEIGHT = 0.45;

        // Paramètres modifiables
        const params = {
            muSlide: 0.2,    // Coefficient de glissement (Tapis)
            muRoll: 0.07,    // Résistance au roulement
            restitution: 0.90, // Rebond billes
            wallRestitution: 0.6,
            maxPower: 25.0, 
            cueHeight: 0.0, 
            showDebug: false
        };

        let camera, scene, renderer, controls, gui;
        let balls = [], whiteBall, cueStick, aimLine;
        let walls2D = []; 

        const mouseState = { isAiming: false, startPos: new THREE.Vector3(), currentPos: new THREE.Vector3(), power: 0, angle: 0 };
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const planeY = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        // --- 2. TEXTURES (Inchangé) ---
        function createBallTexture(number, colorHex) {
            const size = 512; const ctx = document.createElement('canvas').getContext('2d');
            ctx.canvas.width = size; ctx.canvas.height = size/2;
            const w=size, h=size/2;
            ctx.fillStyle = '#fffae6'; ctx.fillRect(0,0,w,h);
            if(number===0) {
                ctx.fillStyle='#ff0000'; ctx.beginPath(); ctx.arc(w*0.5, h*0.5, h*0.05, 0, Math.PI*2); ctx.fill();
                return new THREE.CanvasTexture(ctx.canvas);
            }
            ctx.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
            if(number>8) ctx.fillRect(0, h*0.25, w, h*0.5); else ctx.fillRect(0,0,w,h);
            [w*0.25, w*0.75].forEach(x => {
                ctx.beginPath(); ctx.arc(x, h*0.5, h*0.35, 0, Math.PI*2);
                ctx.fillStyle='#fffae6'; ctx.fill();
                ctx.fillStyle='black'; ctx.font=`bold ${h*0.4}px Arial`;
                ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(number, x, h*0.52);
            });
            const t = new THREE.CanvasTexture(ctx.canvas); t.minFilter = THREE.LinearFilter; return t;
        }

        // --- 3. CLASSE BALLE (MISE À JOUR MAJEURE) ---
        class BilliardBall {
            constructor(x, z, number) {
                this.pos = new THREE.Vector3(x, BALL_RADIUS, z);
                this.vel = new THREE.Vector3(0, 0, 0);
                this.angVel = new THREE.Vector3(0, 0, 0); // Vitesse angulaire (rad/s)
                this.quat = new THREE.Quaternion();
                this.inPocket = false;
                
                // Visuals
                const colors = {1:0xeebb00, 2:0x0000ee, 3:0xee0000, 4:0x800080, 5:0xffa500, 6:0x006400, 7:0x800000, 8:0x111111};
                let c = (number>8 ? colors[number-8] : colors[number]) || 0x000000;
                const geo = new THREE.SphereGeometry(BALL_RADIUS, 32, 16);
                const mat = new THREE.MeshStandardMaterial({ map: createBallTexture(number, c), roughness: 0.1, metalness: 0.1 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                if(number!==0) this.mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                this.mesh.position.copy(this.pos);
                scene.add(this.mesh);
            }

            // --- NOUVEAU PHYSIQUE : Intégration du prototype ---
            update(dt) {
                if (this.inPocket) return;

                // 1. Calcul de la vitesse relative au point de contact (v_slide)
                // v_contact = v + (omega x r)
                // r est le vecteur du centre vers le bas (0, -R, 0)
                const rVector = new THREE.Vector3(0, -BALL_RADIUS, 0);
                const vRot = new THREE.Vector3().crossVectors(this.angVel, rVector);
                const vSlide = new THREE.Vector3().addVectors(this.vel, vRot);
                vSlide.y = 0; // On reste sur le plan 2D

                const slideSpeed = vSlide.length();

                // 2. Application des forces
                if (slideSpeed > 0.01) {
                    // --- ETAT GLISSEMENT (SLIDING) ---
                    // Force de friction opposée au glissement
                    const frictionDir = vSlide.normalize().negate();
                    const frictionMag = params.muSlide * BALL_MASS * GRAVITY;
                    const frictionForce = frictionDir.multiplyScalar(frictionMag);

                    // a. Impact sur la vitesse linéaire (F = ma)
                    const linearAcc = frictionForce.clone().divideScalar(BALL_MASS);
                    this.vel.addScaledVector(linearAcc, dt);

                    // b. Impact sur la vitesse angulaire (Torque = r x F)
                    const torque = new THREE.Vector3().crossVectors(rVector, frictionForce);
                    const angularAcc = torque.divideScalar(INERTIA);
                    this.angVel.addScaledVector(angularAcc, dt);
                } else {
                    // --- ETAT ROULEMENT (ROLLING) ---
                    // Résistance simple au roulement pour arrêter la bille progressivement
                    const k = 1 - (params.muRoll * dt * 10); 
                    this.vel.multiplyScalar(k);
                    this.angVel.multiplyScalar(k);
                    
                    // Seuil d'arrêt
                    if(this.vel.lengthSq() < 0.0001) {
                        this.vel.set(0,0,0);
                        this.angVel.set(0,0,0);
                    }
                }

                // 3. Intégration Position
                this.pos.addScaledVector(this.vel, dt);

                // 4. Intégration Rotation (Quaternion) via angVel réel
                const omegaLen = this.angVel.length();
                if(omegaLen > 0.000001) {
                    const axis = this.angVel.clone().normalize();
                    const angle = omegaLen * dt;
                    const q = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                    this.quat.premultiply(q);
                }

                // 5. Mise à jour Mesh
                this.mesh.position.copy(this.pos);
                this.mesh.quaternion.copy(this.quat);
            }
        }

        // --- 4. INITIALISATION ---
        init(); 

        function init() {
            scene = new THREE.Scene(); 
            scene.background = new THREE.Color(0x050505);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 12, 10); 
            camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lumières
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.SpotLight(0xffffff, 800);
            light.position.set(0, 15, 0); light.castShadow = true;
            light.shadow.mapSize.set(2048,2048);
            scene.add(light);

            createTable(); 
            resetGame(); 
            createCue();
            setupGUI();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.maxPolarAngle = Math.PI/2 - 0.1;

            window.addEventListener('resize', onResize);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('keydown', (e)=>{if(e.code==='Space') resetGame()});

            renderer.setAnimationLoop(animate);
        }

        function setupGUI() {
            gui = new GUI({ title: 'Billard Physique' });
            
            gui.add(params, 'cueHeight', -BALL_RADIUS * 0.8, BALL_RADIUS * 0.8).name('↕ Point d\'impact').onChange(() => {
                if(cueStick.visible) cueStick.position.y = BALL_RADIUS + params.cueHeight;
            });
            gui.add(params, 'maxPower', 10, 50).name('Puissance Max');
            
            const f = gui.addFolder('Réglages Physique').close();
            f.add(params, 'muSlide', 0.05, 0.5).name('Frottement Tapis');
            f.add(params, 'muRoll', 0.001, 0.1).name('Résist. Roulement');
            f.add(params, 'restitution', 0.1, 1.0).name('Rebond Billes');
        }

        // --- 5. LOGIQUE CAMERA & VISÉE ---

        function onMouseDown(e) {
            if(balls.some(b => b.vel.lengthSq() > 0.001 && !b.inPocket)) return; // Attendre arrêt
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(balls.map(b => b.mesh));
            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                if (hitObj === whiteBall.mesh) {
                    mouseState.isAiming = true;
                    controls.enabled = false;
                    raycaster.ray.intersectPlane(planeY, mouseState.startPos);
                    cueStick.visible = true;
                    cueStick.position.y = BALL_RADIUS + params.cueHeight;
                    aimLine.visible = true;
                } else {
                    focusCameraOnTarget(balls.find(b => b.mesh === hitObj));
                }
            }
        }

        function focusCameraOnTarget(target) {
            const direction = new THREE.Vector3().subVectors(target.pos, whiteBall.pos).normalize();
            const angle = Math.atan2(direction.z, direction.x);
            mouseState.angle = angle;
            const camPos = whiteBall.pos.clone().sub(direction.clone().multiplyScalar(8)).add(new THREE.Vector3(0, 10, 0));
            camera.position.copy(camPos);
            controls.target.copy(whiteBall.pos);
            controls.update();
            cueStick.visible = true;
            cueStick.position.copy(whiteBall.pos);
            cueStick.position.y = BALL_RADIUS + params.cueHeight;
            cueStick.rotation.y = -angle - Math.PI/2;
            cueStick.translateZ(0.2); 
            aimLine.visible = true;
            aimLine.position.copy(whiteBall.pos);
            aimLine.rotation.y = -angle;
        }

        function onMouseMove(e) {
            if(!mouseState.isAiming) return;
            updateMouse(e); 
            raycaster.setFromCamera(mouse, camera); 
            raycaster.ray.intersectPlane(planeY, mouseState.currentPos);
            
            const v = new THREE.Vector3().subVectors(whiteBall.pos, mouseState.currentPos);
            const angle = Math.atan2(v.z, v.x);
            const dist = Math.min(v.length() * 3, params.maxPower);
            
            mouseState.angle = angle;
            mouseState.power = dist;

            cueStick.position.copy(whiteBall.pos);
            cueStick.position.y = BALL_RADIUS + params.cueHeight;
            cueStick.rotation.y = -angle - Math.PI/2;
            cueStick.translateZ(dist * 0.1); 

            aimLine.position.copy(whiteBall.pos); 
            aimLine.rotation.y = -angle;
        }

        function onMouseUp() {
            if(!mouseState.isAiming) return;
            shootBall();
            mouseState.isAiming = false; 
            cueStick.visible = false; 
            aimLine.visible = false; 
            controls.enabled = true;
        }

        // --- NOUVEAU SHOOT : Gère correctement la vitesse angulaire ---
        function shootBall() {
            const dir = new THREE.Vector3(Math.cos(mouseState.angle), 0, Math.sin(mouseState.angle));
            
            // 1. Vitesse Linéaire
            // F = ma -> v = (F * dt) / m. On simplifie : power est directement proportionnel à v
            const speed = mouseState.power; 
            whiteBall.vel.copy(dir.clone().multiplyScalar(speed));
            
            // 2. Vitesse Angulaire (Coup décentré)
            // Calcul du torque basé sur le point d'impact
            // r = vecteur du centre de la bille vers le point d'impact
            // Point d'impact supposé à l'arrière de la bille par rapport au tir
            // Mais pour simplifier l'UI : cueHeight est la hauteur Y relative au centre
            
            const h = params.cueHeight;
            const impactPoint = new THREE.Vector3(0, h, 0); // Simplification locale
            
            // Force appliquée dans la direction du tir
            const forceDir = dir.clone(); 
            const forceMag = mouseState.power * BALL_MASS * 50; // Facteur arbitraire pour sentir l'effet
            const forceVec = forceDir.multiplyScalar(forceMag);

            // Torque = r x F
            const torque = new THREE.Vector3().crossVectors(impactPoint, forceVec);
            
            // Angular Acc = Torque / Inertia -> AngVel += Angular Acc * dt (impulse approximation)
            // On ajoute directement à la vitesse angulaire instantanée
            const impulseDt = 0.01; // Temps de contact fictif
            whiteBall.angVel.add(torque.divideScalar(INERTIA).multiplyScalar(impulseDt));
        }

        function updateMouse(e) { mouse.x=(e.clientX/window.innerWidth)*2-1; mouse.y=-(e.clientY/window.innerHeight)*2+1; }
        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- 6. CONSTRUCTION TABLE (Inchangé) ---
        function createTable() {
            const floorW = TABLE_W + (RUBBER_DEPTH + FRAME_WIDTH)*2;
            const floorH = TABLE_H + (RUBBER_DEPTH + FRAME_WIDTH)*2;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(floorW, floorH), new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.8 }));
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; scene.add(floor);

            walls2D = [];

            function buildSolidRail(p1, p2, normal) {
                const vecDir = new THREE.Vector3().subVectors(p2, p1).normalize();
                const facingSpread = RUBBER_DEPTH * 0.7; 
                const p4 = p1.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(-facingSpread));
                const p3 = p2.clone().add(normal.clone().multiplyScalar(RUBBER_DEPTH)).add(vecDir.clone().multiplyScalar(facingSpread));

                const shape = new THREE.Shape(); shape.moveTo(p1.x, p1.z); shape.lineTo(p2.x, p2.z); shape.lineTo(p3.x, p3.z); shape.lineTo(p4.x, p4.z);
                const geom = new THREE.ExtrudeGeometry(shape, { depth: RAIL_HEIGHT, bevelEnabled: false });
                geom.rotateX(Math.PI / 2); geom.translate(0, RAIL_HEIGHT, 0);
                const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color: 0x247a46, roughness: 0.6 }));
                mesh.castShadow = true; scene.add(mesh);

                const w1 = p4.clone(); const w2 = p3.clone(); const w3 = w2.clone().add(normal.clone().multiplyScalar(WOOD_DEPTH)); const w4 = w1.clone().add(normal.clone().multiplyScalar(WOOD_DEPTH));
                const mitre = WOOD_DEPTH * 0.8; w3.add(vecDir.clone().multiplyScalar(mitre)); w4.add(vecDir.clone().multiplyScalar(-mitre));
                const wShape = new THREE.Shape(); wShape.moveTo(w1.x, w1.z); wShape.lineTo(w2.x, w2.z); wShape.lineTo(w3.x, w3.z); wShape.lineTo(w4.x, w4.z);
                const wGeom = new THREE.ExtrudeGeometry(wShape, { depth: RAIL_HEIGHT + 0.05, bevelEnabled: false });
                wGeom.rotateX(Math.PI/2); wGeom.translate(0, RAIL_HEIGHT + 0.05, 0);
                scene.add(new THREE.Mesh(wGeom, new THREE.MeshStandardMaterial({color:0x5c4033})));

                addWallSegment(p4, p1); addWallSegment(p1, p2); addWallSegment(p2, p3);
            }
            function addWallSegment(a, b) {
                const dx = b.x - a.x; const dz = b.z - a.z; const len = Math.sqrt(dx*dx + dz*dz);
                walls2D.push({ p1: a, p2: b, normal: {x: dz/len, z: -dx/len}, lenSq: len*len });
            }

            const W = TABLE_W/2; const H = TABLE_H/2;
            buildSolidRail(new THREE.Vector3(-W + CORNER_KNUCKLE, 0, -H), new THREE.Vector3(-SIDE_KNUCKLE, 0, -H), new THREE.Vector3(0, 0, -1));
            buildSolidRail(new THREE.Vector3(SIDE_KNUCKLE, 0, -H), new THREE.Vector3(W - CORNER_KNUCKLE, 0, -H), new THREE.Vector3(0, 0, -1));
            buildSolidRail(new THREE.Vector3(W, 0, -H + CORNER_KNUCKLE), new THREE.Vector3(W, 0, H - CORNER_KNUCKLE), new THREE.Vector3(1, 0, 0));
            buildSolidRail(new THREE.Vector3(W - CORNER_KNUCKLE, 0, H), new THREE.Vector3(SIDE_KNUCKLE, 0, H), new THREE.Vector3(0, 0, 1));
            buildSolidRail(new THREE.Vector3(-SIDE_KNUCKLE, 0, H), new THREE.Vector3(-W + CORNER_KNUCKLE, 0, H), new THREE.Vector3(0, 0, 1));
            buildSolidRail(new THREE.Vector3(-W, 0, H - CORNER_KNUCKLE), new THREE.Vector3(-W, 0, -H + CORNER_KNUCKLE), new THREE.Vector3(-1, 0, 0));

            // Cadre & Trous (Simplifié pour lisibilité, même que avant)
            const createCabinet = () => {
                const shape = new THREE.Shape();
                const innerW = W + RUBBER_DEPTH; const innerH = H + RUBBER_DEPTH;
                const outerW = innerW + FRAME_WIDTH; const outerH = innerH + FRAME_WIDTH;
                shape.moveTo(-outerW, -outerH); shape.lineTo(outerW, -outerH); shape.lineTo(outerW, outerH); shape.lineTo(-outerW, outerH); shape.lineTo(-outerW, -outerH);
                const hole = new THREE.Path(); hole.moveTo(-innerW, -innerH); hole.lineTo(innerW, -innerH); hole.lineTo(innerW, innerH); hole.lineTo(-innerW, innerH); hole.lineTo(-innerW, -innerH);
                shape.holes.push(hole);
                const geom = new THREE.ExtrudeGeometry(shape, { depth: FRAME_HEIGHT, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 });
                geom.rotateX(Math.PI / 2); geom.translate(0, FRAME_HEIGHT, 0);
                scene.add(new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.4 })));
            };
            createCabinet();
            const holeGeo = new THREE.CylinderGeometry(VAL_HOLE_RADIUS, VAL_HOLE_RADIUS, 0.5, 32); const holeMat = new THREE.MeshBasicMaterial({color: 0x000000});
            const diagX = Math.cos(Math.PI/4)*VAL_OFFSET_CORNER, diagZ = Math.sin(Math.PI/4)*VAL_OFFSET_CORNER;
            const pp = [{x:-W-diagX,z:-H-diagZ}, {x:W+diagX,z:-H-diagZ}, {x:0,z:-H-VAL_OFFSET_SIDE}, {x:-W-diagX,z:H+diagZ}, {x:W+diagX,z:H+diagZ}, {x:0,z:H+VAL_OFFSET_SIDE}];
            pp.forEach(p => { const m = new THREE.Mesh(holeGeo, holeMat); m.position.set(p.x, -0.1, p.z); scene.add(m); });
        }

        // --- 7. HELPERS ---
        function resetGame() {
            balls.forEach(b=>scene.remove(b.mesh)); balls=[];
            whiteBall = new BilliardBall(-TABLE_W/4, 0, 0); balls.push(whiteBall);
            const startX = TABLE_W/4, rS = BALL_RADIUS*1.732, cS = BALL_RADIUS*2.01;
            const p = [1,10,2,3,8,11,12,5,13,4,6,14,7,15,9]; let k=0;
            for(let r=0;r<5;r++) for(let i=0;i<=r;i++) balls.push(new BilliardBall(startX+r*rS, (i-r/2)*cS, p[k++]));
        }
        function resetWhiteBall() { whiteBall.inPocket=false; whiteBall.mesh.visible=true; whiteBall.pos.set(-TABLE_W/4, BALL_RADIUS, 0); whiteBall.vel.set(0,0,0); whiteBall.angVel.set(0,0,0); }
        function createCue() {
            const g = new THREE.CylinderGeometry(0.04, 0.08, 3, 12); g.rotateX(-Math.PI/2); g.translate(0,0,1.7);
            cueStick = new THREE.Mesh(g, new THREE.MeshStandardMaterial({color:0xdeb887})); scene.add(cueStick); cueStick.visible=false;
            aimLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(3,0,0)]), new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.5})); scene.add(aimLine); aimLine.visible=false;
        }

        // --- 8. MOTEUR PHYSIQUE ---
        function animate() {
            controls.update(); 
            const sub=15; const dt=0.016/sub;
            for(let s=0;s<sub;s++) {
                
                // Collisions Balles (Choc Elastique Simple sur la vitesse linéaire)
                for(let i=0;i<balls.length;i++) for(let j=i+1;j<balls.length;j++) {
                    const b1=balls[i], b2=balls[j]; if(b1.inPocket||b2.inPocket)continue;
                    const dv = new THREE.Vector3().subVectors(b2.pos, b1.pos); const d = dv.length();
                    if(d<BALL_RADIUS*2) {
                        const n = dv.normalize(); const pen = (BALL_RADIUS*2-d)*0.5; b1.pos.sub(n.clone().multiplyScalar(pen)); b2.pos.add(n.clone().multiplyScalar(pen));
                        const vRel = new THREE.Vector3().subVectors(b1.vel, b2.vel).dot(n); if(vRel<0) continue;
                        const imp = n.multiplyScalar(-(1+params.restitution)*vRel*0.5); b1.vel.add(imp); b2.vel.sub(imp);
                        // Note : Le transfert de spin entre billes est ignoré ici pour simplifier, 
                        // mais la friction table/bille va rétablir le roulement naturel après le choc.
                    }
                }

                balls.forEach(b => {
                    // Murs 2D
                    for(let w of walls2D) {
                        const abx=w.p2.x-w.p1.x, abz=w.p2.z-w.p1.z, apx=b.pos.x-w.p1.x, apz=b.pos.z-w.p1.z;
                        let t = (apx*abx + apz*abz)/w.lenSq; t = Math.max(0, Math.min(1, t));
                        const cx = w.p1.x + t*abx, cz = w.p1.z + t*abz;
                        const dx = b.pos.x - cx, dz = b.pos.z - cz, dSq = dx*dx + dz*dz;
                        if(dSq < BALL_RADIUS*BALL_RADIUS) {
                            const dist = Math.sqrt(dSq); let nx, nz;
                            if(dist<1e-5){nx=w.normal.x; nz=w.normal.z;} else {nx=dx/dist; nz=dz/dist;}
                            b.pos.x += nx*(BALL_RADIUS-dist); b.pos.z += nz*(BALL_RADIUS-dist);
                            const vn = b.vel.x*nx + b.vel.z*nz;
                            if(vn<0) { 
                                const j = -(1+params.wallRestitution)*vn; 
                                b.vel.x += nx*j; b.vel.z += nz*j; 
                                // On réduit un peu le spin au contact bande
                                b.angVel.multiplyScalar(0.9);
                            }
                        }
                    }

                    // Trous
                    const W = TABLE_W/2, H = TABLE_H/2, dX = Math.cos(Math.PI/4)*VAL_OFFSET_CORNER, dZ = Math.sin(Math.PI/4)*VAL_OFFSET_CORNER;
                    const pp=[{x:-W-dX,z:-H-dZ},{x:W+dX,z:-H-dZ},{x:0,z:-H-VAL_OFFSET_SIDE},{x:-W-dX,z:H+dZ},{x:W+dX,z:H+dZ},{x:0,z:H+VAL_OFFSET_SIDE}];
                    for(let p of pp) {
                        const dx=b.pos.x-p.x, dz=b.pos.z-p.z;
                        if(dx*dx+dz*dz < VAL_HOLE_RADIUS*VAL_HOLE_RADIUS) {
                            b.inPocket=true; b.vel.set(0,0,0); b.angVel.set(0,0,0); b.mesh.visible=false;
                            if(b===whiteBall) setTimeout(resetWhiteBall, 1000);
                        }
                    }

                    // Mise à jour Physique (Frottement, Rotation, Glissement)
                    b.update(dt);
                });
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>